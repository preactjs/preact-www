---
title: Веб-компоненты
description: Как использовать веб-компоненты с Preact
---

# Веб-компоненты

Малый размер Preact и его ориентированность на стандарты делают его отличным выбором для создания веб-компонентов.

Веб-компоненты — это набор стандартов, которые позволяют создавать новые типы HTML-элементов — пользовательские элементы, такие как `<material-card>` или `<tab-bar>`.
Preact [полностью поддерживает эти стандарты](https://custom-elements-everywhere.com/#preact), позволяя бесшовное использование жизненного цикла пользовательских элементов, свойств и событий.

Preact предназначен для рендеринга как полных приложений, так и отдельных частей страницы, что делает его естественным выбором для создания веб-компонентов. Многие компании используют его для создания систем компонентов или дизайна, которые затем упаковываются в набор веб-компонентов, обеспечивая повторное использование в нескольких проектах и в других фреймворках.

Preact и веб-компоненты дополняют друг друга: веб-компоненты предоставляют набор низкоуровневых примитивов для расширения браузера, а Preact предоставляет высокоуровневую модель компонентов, которая может опираться на эти примитивы.

---

<toc></toc>

---

## Рендеринг веб-компонентов

В Preact веб-компоненты работают так же, как и другие DOM-элементы. Они могут быть отрендерены с использованием зарегистрированного имени тега:

```jsx
customElements.define(
	'x-foo',
	class extends HTMLElement {
		// ...
	}
);

function Foo() {
	return <x-foo />;
}
```

### Свойства и атрибуты

JSX не предоставляет способа различать свойства и атрибуты. Пользовательские элементы обычно полагаются на пользовательские свойства для поддержки установки сложных значений, которые нельзя выразить как атрибуты. Это хорошо работает в Preact, потому что рендерер автоматически определяет, устанавливать ли значения с использованием свойства или атрибута, проверяя соответствующий DOM-элемент. Когда пользовательский элемент определяет [сеттер](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set) для данного свойства, Preact обнаруживает его существование и будет использовать сеттер вместо атрибута.

```jsx
customElements.define(
	'context-menu',
	class extends HTMLElement {
		set position({ x, y }) {
			this.style.cssText = `left:${x}px; top:${y}px;`;
		}
	}
);

function Foo() {
	return <context-menu position={{ x: 10, y: 20 }}> ... </context-menu>;
}
```

> **Примечание:** Preact не делает никаких предположений о схемах именования и не пытается принудительно преобразовывать имена, в JSX или иначе, к DOM-свойствам. Если у пользовательского элемента есть имя свойства `someProperty`, оно должно быть установлено с использованием `someProperty=...` а не `some-property=...`.

При рендеринге статического HTML с использованием `preact-render-to-string` («SSR»), сложные значения свойств, такие как объект выше, не автоматически сериализуются. Они применяются после гидратации статического HTML на клиенте.

### Доступ к методам экземпляра

Чтобы получить доступ к экземпляру нашего пользовательского веб-компонента, мы можем использовать `refs`:

```jsx
function Foo() {
	const myRef = useRef(null);

	useEffect(() => {
		if (myRef.current) {
			myRef.current.doSomething();
		}
	}, []);

	return <x-foo ref={myRef} />;
}
```

### Вызов пользовательских событий

Preact нормализует регистр встроенных DOM-событий, которые обычно чувствительны к регистру. Вот почему возможно передать проп `onChange` в `<input>`, несмотря на то, что фактическое имя события — `"change"`. Пользовательские элементы часто запускают пользовательские события как часть своего публичного API, однако нет способа знать, какие пользовательские события могут быть запущены. Чтобы обеспечить бесшовную поддержку пользовательских элементов в Preact, необработанные пропсы обработчиков событий, переданные DOM-элементу, регистрируются с использованием их регистра точно так, как указано.

```jsx
// Встроенное DOM-событие: прослушивает событие "click"
<input onClick={() => console.log('клик')} />

// Пользовательский элемент: прослушивает событие "TabChange" (чувствительно к регистру!)
<tab-bar onTabChange={() => console.log('вкладка меняется')} />

// Исправлено: прослушивает событие "tabchange" (нижний регистр)
<tab-bar ontabchange={() => console.log('вкладка меняется')} />
```

## Создание веб-компонента

Любой компонент Preact может быть превращен в веб-компонент с помощью [preact-custom-element](https://github.com/preactjs/preact-custom-element), очень тонкой обёртки, которая соответствует спецификации Custom Elements v1.

```jsx
import register from 'preact-custom-element';

const Greeting = ({ name = 'World' }) => <p>Привет, {name}!</p>;

register(Greeting, 'x-greeting', ['name'], { shadow: false });
//          ^            ^           ^             ^
//          |      HTML-тег       |       использовать shadow-dom
//   Определение компонента      Отслеживаемые атрибуты
```

> Примечание: Согласно [Спецификации Пользовательских элементов](http://w3c.github.io/webcomponents/spec/custom/#prod-potentialcustomelementname), имя тега должно содержать дефис (`-`).

Используйте новое имя тега в HTML, ключи атрибутов и значения будут переданы как пропсы:

```html
<x-greeting name="Вася Пупкин"></x-greeting>
```

Вывод:

```html
<p>Привет, Вася Пупкин!</p>
```

### Отслеживаемые атрибуты

Веб-компоненты требуют явного перечисления имен атрибутов, которые вы хотите отслеживать, чтобы реагировать на изменения их значений. Они могут быть указаны через третий параметр, передаваемый функции `register()`:

```jsx
// Прослушиваем изменения атрибута `name`
register(Greeting, 'x-greeting', ['name']);
```

Если вы опустите третий параметр для `register()`, список атрибутов для отслеживания может быть указан с использованием статического свойства `observedAttributes` на компоненте. Это также работает для имени Пользовательского элемента, которое может быть указано с использованием статического свойства `tagName`:

```jsx
import register from 'preact-custom-element';

// <x-greeting name="Bo"></x-greeting>
class Greeting extends Component {
	// Регистрируем как <x-greeting>:
	static tagName = 'x-greeting';

	// Отслеживаем эти атрибуты:
	static observedAttributes = ['name'];

	render({ name }) {
		return <p>Привет, {name}!</p>;
	}
}
register(Greeting);
```

Если `observedAttributes` не указаны, они будут выведены из ключей `propTypes`, если присутствуют на компоненте:

```jsx
// Другой вариант: используйте PropTypes:
function FullName({ first, last }) {
	return (
		<span>
			{first} {last}
		</span>
	);
}

FullName.propTypes = {
	first: Object, // вы можете использовать PropTypes, или это
	last: Object // трюк для определения не-типизированных пропсов.
};

register(FullName, 'full-name');
```

### Передача слотов как пропсов

Функция `register()` имеет четвертый параметр для передачи опций; в настоящее время поддерживается только опция `shadow`, которая прикрепляет дерево shadow DOM к указанному элементу. При включении это позволяет использовать именованные элементы `<slot>` для пересылки дочерних элементов пользовательского элемента к определённым местам в дереве shadow.

```jsx
function TextSection({ heading, content }) {
	return (
		<div>
			<h1>{heading}</h1>
			<p>{content}</p>
		</div>
	);
}

register(TextSection, 'text-section', [], { shadow: true });
```

Использование:

```html
<text-section>
	<span slot="heading">Приятный заголовок</span>
	<span slot="content">Шикарный контент</span>
</text-section>
```
