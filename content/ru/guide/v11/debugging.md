---
title: Отладка приложений Preact
description: Как отлаживать приложения Preact, когда что-то идёт не так
---

# Отладка приложений Preact

Preact поставляется с множеством инструментов, чтобы сделать отладку проще. Они упакованы в один импорт и могут быть включены путём импорта `preact/debug`.

Они включают интеграцию с нашим собственным [расширением Preact Devtools] для Chrome и Firefox.

Мы будем выводить предупреждение или ошибку всякий раз, когда обнаружим что-то неправильное, например некорректное вложение в элементах `<table>`.

---

<toc></toc>

---

## Установка

[Preact Devtools] можно установить в магазине расширений вашего браузера.

- [Для Chrome](https://chrome.google.com/webstore/detail/preact-developer-tools/ilcajpmogmhpliinlbcdebhbcanbghmd)
- [Для Firefox](https://addons.mozilla.org/en-US/firefox/addon/preact-devtools/)
- [Для Edge](https://microsoftedge.microsoft.com/addons/detail/hdkhobcafnfejjieimdkmjaiihkjpmhk)

После установки нам нужно где-то импортировать `preact/debug`, чтобы инициализировать соединение с расширением. Убедитесь, что этот импорт является **первым** импортом в вашем приложении.

> `@preact/preset-vite` включает пакет `preact/debug` автоматически. Вы можете безопасно пропустить шаги настройки и удаления, если вы его используете!

Вот пример того, как может выглядеть ваш основной файл входа в приложение.

```jsx
// Должен быть первым импортом
import 'preact/debug';
import { render } from 'preact';
import App from './components/App';

render(<App />, document.getElementById('root'));
```

### Удаление devtools из продакшена

Большинство сборщиков позволяют удалять код, когда они обнаруживают, что ветвь внутри `if`-оператора никогда не будет достигнута. Мы можем использовать это, чтобы включать `preact/debug` только во время разработки и сэкономить драгоценные байты в продакшен-сборке.

```jsx
// Должен быть первым импортом
if (process.env.NODE_ENV === 'development') {
	// Должен использовать require здесь, поскольку операторы import разрешены
	// только на верхнем уровне.
	require('preact/debug');
}

import { render } from 'preact';
import App from './components/App';

render(<App />, document.getElementById('root'));
```

Убедитесь, что установили переменную `NODE_ENV` в правильное значение в вашем инструменте сборки.

## Предупреждения и ошибки отладки

Иногда вы можете получать предупреждения или ошибки, когда Preact обнаруживает недопустимый код. Их следует исправить, чтобы обеспечить безупречную работу вашего приложения.

### В `render()` передан `undefined` вместо родительского элемента

Это означает, что код пытается отрендерить ваше приложение в «никуда» вместо DOM-узла. Разница между:

```jsx
// Что получил Preact
render(<App />, undefined);

// против того, что ожидалось
render(<App />, actualDomNode);
```

Главная причина этой ошибки — DOM-узел отсутствует, когда вызвана функция `render()`. Убедитесь, что он существует.

### В `createElement()` передан `undefined` вместо компонента

Preact будет выбрасывать эту ошибку при передаче `undefined` вместо компонента. Распространённая причина — путаница между `default` и `named` экспортами.

```jsx
// app.js
export default function App() {
	return <div>Привет, мир</div>;
}

// index.js: Неправильно, потому что `app.js` не имеет именованного экспорта
import { App } from './app';
render(<App />, dom);
```

Та же ошибка будет выброшена и в обратном случае. Когда вы объявляете `named` экспорт и пытаетесь использовать его как `default` экспорт. Один быстрый способ проверить это (если ваш редактор уже не делает этого), — просто залогировать импорт:

```jsx
// app.js
export function App() {
	return <div>Привет, мир</div>;
}

// index.js
import App from './app';

console.log(App);
// Логирует: { default: [Function] } вместо компонента
```

### JSX-литерал передан в JSX дважды

Передача JSX-литерала или компонента внутрь JSX повторно недопустима и вызовет эту ошибку.

```jsx
const Foo = <div>foo</div>;
// Недопустимо: Foo уже содержит JSX-элемент
render(<Foo />, dom);
```

Чтобы исправить это, мы можем просто передать переменную напрямую:

```jsx
const Foo = <div>foo</div>;
render(Foo, dom);
```

### Обнаружена неправильная вложенность таблицы

HTML-парсеры имеют очень строгие правила относительно структуры таблиц, и отклонение от этих правил приводит к ошибкам рендеринга, которые трудно отладить. Чтобы помочь с этим, Preact может обнаруживать неправильную вложенность в различных ситуациях и выводить предупреждения для раннего обнаружения проблем. Чтобы узнать больше о структуре таблиц, мы настоятельно рекомендуем [документацию MDN](https://developer.mozilla.org/en-US/docs/Learn/HTML/Tables/Basics).

> **Примечание:** В этом контексте "строгий" относится к _выводу_ HTML-парсера, а не к _вводу_. Браузеры довольно снисходительны и пытаются исправить неверный HTML, чтобы обеспечить отображение страниц. Однако для VDOM-библиотек, таких как Preact, это может вызвать проблемы, поскольку входное содержимое может не соответствовать выходному после коррекции браузером, о которой Preact не будет знать.
>
> Например, элементы `<tr>` всегда должны быть дочерними элементами `<tbody>`, `<thead>` или `<tfoot>` согласно спецификации, но если вы напишете `<tr>` непосредственно внутри `<table>`, браузер попытается исправить это, автоматически обернув его в элемент `<tbody>`. Поэтому Preact будет ожидать структуру DOM как `<table><tr></tr></table>`, но реальная DOM-структура, созданная браузером, будет `<table><tbody><tr></tr></tbody></table>`.

### Недопустимое свойство `ref`

Когда свойство `ref` содержит неожиданное значение, мы выбрасываем эту ошибку. Это включает строковые `refs`, которые были объявлены устаревшими некоторое время назад.

```jsx
// допустимо
<div ref={e => {/* ... */)}} />

// допустимо
const ref = createRef();
<div ref={ref} />

// Недопустимо
<div ref="ref" />
```

### Недопустимый обработчик событий

Иногда вы можете случайно передать неправильное значение обработчику событий. Они всегда должны быть `function` или `null`, если вы хотите удалить его. Все остальные типы недопустимы.

```jsx
// допустимо
<div onClick={() => console.log("click")} />

// недопустимо
<div onClick={console.log("click")} />
```

### Хук может быть вызван только из render методов

Эта ошибка возникает, когда вы пытаетесь использовать хук вне компонента. Они поддерживаются только внутри функционального компонента.

```jsx
// Недопустимо, должен использоваться внутри компонента
const [value, setValue] = useState(0);

// допустимо
function Foo() {
	const [value, setValue] = useState(0);
	return <button onClick={() => setValue(value + 1)}>{value}</button>;
}
```

### Получение `vnode.[property]` считается устаревшим

В Preact X мы внесли некоторые критические изменения во внутреннюю структуру `vnode`.

| Preact 8.x         | Preact 10.x            |
| ------------------ | ---------------------- |
| `vnode.nodeName`   | `vnode.type`           |
| `vnode.attributes` | `vnode.props`          |
| `vnode.children`   | `vnode.props.children` |

### Обнаружены дочерние элементы с одинаковым ключом

Уникальная особенность библиотек, основанных на Vrtual Dom, заключается в том, что они должны отслеживать перемещение дочерних элементов. Однако чтобы определить, какой элемент какой, нам необходимо каким-то образом их пометить. _Это необходимо только при динамическом создании дочерних элементов._

```jsx
// Оба потомка будут иметь одинаковый ключ "A"
<div>
	{['A', 'A'].map(char => (
		<p key={char}>{char}</p>
	))}
</div>
```

Правильный способ сделать это — дать им уникальные ключи. В большинстве случаев данные, по которым вы итерируете, будут иметь какую-то форму `id`.

```jsx
const persons = [
	{ name: 'Пётр', age: 22 },
	{ name: 'Марина', age: 24 }
];

// Где-то позже в вашем компоненте
<div>
	{persons.map(({ name, age }) => {
		return (
			<p key={name}>
				{name}, Возраст: {age}
			</p>
		);
	})}
</div>;
```

[preact devtools]: https://preactjs.github.io/preact-devtools/
