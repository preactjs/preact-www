---
title: Сигналы
description: Составляемое реактивное состояние с автоматическим рендерингом
---

# Сигналы

Сигналы — это реактивные примитивы для управления состоянием приложения.

Что делает сигналы уникальными, так это то, что изменения состояния автоматически обновляют компоненты и UI наиболее эффективным способом. Автоматическая привязка состояния и отслеживание зависимостей позволяют сигналам обеспечивать отличную эргономику и производительность, устраняя наиболее распространённые проблемы управления состоянием.

Сигналы эффективны в приложениях любого размера, с эргономикой, которая ускоряет разработку небольших приложений, и характеристиками производительности, которые делают быстрыми приложения любого размера по умолчанию.

---

**Важно**

Это руководство охватывает использование сигналов в Preact, и хотя это в основном применимо как к Core, так и к React библиотекам, будут некоторые различия в использовании. Информация по их использованию находятся в соответствующих документациях: [`@preact/signals-core`](https://github.com/preactjs/signals), [`@preact/signals-react`](https://github.com/preactjs/signals/tree/main/packages/react)

---

<toc></toc>

---

## Введение

Много боли в управлении состоянием в JavaScript заключается в реакции на изменения для данного значения, потому что значения не являются непосредственно наблюдаемыми. Решения обычно обходят это, сохраняя значения в переменную и постоянно проверяя, изменились ли они, что обременительно и не идеально для производительности. В идеале нам нужен способ выразить значение, которое говорит нам, когда оно изменяется. Это то, что делают сигналы.

В основе своей сигнал — это объект со свойством `.value`, которое содержит значение. Это имеет важную характеристику: значение сигнала может изменяться, но сам сигнал всегда остается тем же:

```js
// --repl
import { signal } from '@preact/signals';

const count = signal(0);

// Читаем значение сигнала, обращаясь к .value:
console.log(count.value); // 0

// Обновляем значение сигнала:
count.value += 1;

// Значение сигнала изменилось:
console.log(count.value); // 1
```

В Preact, когда сигнал передается вниз по дереву как пропсы или контекст, мы только передаем ссылки на сигнал. Сигнал может быть обновлен без повторного рендеринга компонентов, поскольку компоненты видят сигнал, а не его значение. Это позволяет нам пропустить всю дорогую работу рендеринга и сразу перейти к компонентам в дереве, которые фактически обращаются к свойству `.value` сигнала.

Сигналы имеют вторую важную характеристику, которая заключается в том, что они отслеживают, когда к их значению обращаются и когда оно обновляется. В Preact обращение к свойству `.value` сигнала изнутри компонента автоматически перерендерит компонент, когда значение этого сигнала изменится.

```jsx
// --repl
import { render } from 'preact';
// --repl-before
import { signal } from '@preact/signals';

// Создаем сигнал, на который можно подписаться:
const count = signal(0);

function Counter() {
	// Обращение к .value в компоненте автоматически перерендерится при изменении:
	const value = count.value;

	const increment = () => {
		// Сигнал обновляется путем присваивания к .value свойству:
		count.value++;
	};

	return (
		<div>
			<p>Счётчик: {value}</p>
			<button onClick={increment}>нажми именя</button>
		</div>
	);
}
// --repl-after
render(<Counter />, document.getElementById('app'));
```

Наконец, сигналы глубоко интегрированы в Preact, чтобы обеспечить лучшую возможную производительность и эргономику. В примере выше мы обращались к `count.value`, чтобы получить текущее значение сигнала `count`, однако это необязательно. Вместо этого мы можем позволить Preact делать всю работу за нас, используя сигнал `count` непосредственно в JSX:

```jsx
// --repl
import { render } from 'preact';
// --repl-before
import { signal } from '@preact/signals';

const count = signal(0);

function Counter() {
	return (
		<div>
			<p>Счётчик: {count}</p>
			<button onClick={() => count.value++}>нажми именя</button>
		</div>
	);
}
// --repl-after
render(<Counter />, document.getElementById('app'));
```

## Установка

Сигналы могут быть установлены путём добавления пакета `@preact/signals` к вашему проекту:

```bash
npm install @preact/signals
```

Как только пакет будет установлен, вы готовы импортировать его в ваше приложение.

## Пример использования

Давайте использовать сигналы в реальном сценарии. Мы собираемся создать приложение списка задач, где вы можете добавлять и удалять элементы в списке задач. Мы начнем с моделирования состояния. Нам понадобится сигнал, который содержит список задач, который мы можем представить с помощью `Array`:

```jsx
import { signal } from '@preact/signals';

const todos = signal([{ text: 'Купить продукты' }, { text: 'Выгулять собаку' }]);
```

Чтобы позволить пользователю вводить текст для нового элемента задачи, нам понадобится еще один сигнал, который мы скоро подключим к элементу `<input>`. Пока мы можем использовать этот сигнал уже для создания функции, которая добавляет элемент задачи в наш список. Помните, мы можем обновить значение сигнала, присваивая его `.value` свойству:

```jsx
// Мы будем использовать это для нашего ввода позже
const text = signal('');

function addTodo() {
	todos.value = [...todos.value, { text: text.value }];
	text.value = ''; // Очистить значение ввода при добавлении
}
```

> :bulb: Совет: Сигнал обновится только если вы присвоите ему новое значение. Если значение, которое вы присваиваете сигналу, равно его текущему значению, он не обновится.
>
> ```js
> const count = signal(0);
>
> count.value = 0; // ничего не делает - значение уже 0
>
> count.value = 1; // обновляется - значение другое
> ```

Давайте проверим, правильна ли наша логика до сих пор. Когда мы обновляем сигнал `text` и вызываем `addTodo()`, мы должны увидеть новый элемент, добавленный к сигналу `todos`. Мы можем симулировать этот сценарий, вызывая эти функции напрямую — пока не нужен пользовательский интерфейс!

```jsx
// --repl
import { signal } from '@preact/signals';

const todos = signal([{ text: 'Купить продукты' }, { text: 'Выгулять собаку' }]);

const text = signal('');

function addTodo() {
	todos.value = [...todos.value, { text: text.value }];
	text.value = ''; // Сбросить значение ввода при добавлении
}

// Проверить, работает ли наша логика
console.log(todos.value);
// Логирует: [{text: "Купить продукты"}, {text: "Выгулять собаку"}]

// Симулировать добавление новой задачи
text.value = 'Tidy up';
addTodo();

// Проверить, что добавлен новый элемент и очищен сигнал `text`:
console.log(todos.value);
// Логирует: [{text: "Купить продукты"}, {text: "Выгулять собаку"}, {text: "Tidy up"}]

console.log(text.value); // Логирует: ""
```

Последняя функция, которую мы хотели бы добавить, — это возможность удалить элемент задачи из списка. Для этого мы добавим функцию, которая удаляет данный элемент задачи из массива `todos`:

```jsx
function removeTodo(todo) {
	todos.value = todos.value.filter(t => t !== todo);
}
```

## Создание UI

Теперь, когда мы смоделировали состояние нашего приложения, пришло время подключить его к красивому UI, с которым пользователи могут взаимодействовать.

```jsx
function TodoList() {
	const onInput = event => (text.value = event.currentTarget.value);

	return (
		<>
			<input value={text.value} onInput={onInput} />
			<button onClick={addTodo}>Добавить</button>
			<ul>
				{todos.value.map(todo => (
					<li>
						{todo.text} <button onClick={() => removeTodo(todo)}>❌</button>
					</li>
				))}
			</ul>
		</>
	);
}
```

И вот у нас полностью рабочее приложение списка задач! Вы можете попробовать полное приложение [здесь](/repl?example=todo-signals) :tada:

## Вывод состояния через вычисляемые сигналы

Давайте добавим ещё одну функцию к нашему приложению списка задач: каждый элемент задачи может быть отмечен как завершенный, и мы покажем пользователю количество завершённых ими элементов. Для этого мы импортируем функцию [`computed(fn)`](#computedfn), которая позволяет нам создать новый сигнал, вычисляемый на основе значений других сигналов. Возвращаемый вычисляемый сигнал доступен только для чтения, и его значение автоматически обновляется, когда любые сигналы, доступные изнутри функции обратного вызова, изменяются.

```jsx
// --repl
import { signal, computed } from '@preact/signals';

const todos = signal([
	{ text: 'Купить продукты', completed: true },
	{ text: 'Выгулять собаку', completed: false }
]);

// создать сигнал, вычисляемый из других сигналов
const completed = computed(() => {
	// Когда `todos` изменяется, это автоматически перезапускается:
	return todos.value.filter(todo => todo.completed).length;
});

// Логирует: 1, потому что одна задача отмечена как завершенная
console.log(completed.value);
```

Наше простое приложение списка задач не нуждается во многих вычисляемых сигналах, но более сложные приложения склонны полагаться на `computed()`, чтобы избежать дублирования состояния в нескольких местах.

> :bulb: Совет: вывод как можно большего количества состояния обеспечивает, что ваше состояние всегда имеет единственный источник истины. Это ключевой принцип сигналов. Это делает отладку намного легче в случае, если есть недостаток в логике приложения позже, так как меньше мест, о которых нужно беспокоиться.

## Управление глобальным состоянием приложения

До сих пор мы создавали сигналы только вне дерева компонентов. Это нормально для небольшого приложения вроде списка задач, но для больших и более сложных приложений это может сделать тестирование трудным. Тесты обычно включают изменение значений в вашем состоянии приложения для воспроизведения определенного сценария, затем передачу этого состояния компонентам и утверждение на отрендеренном HTML. Для этого мы можем извлечь наше состояние списка задач в функцию:

```jsx
function createAppState() {
	const todos = signal([]);

	const completed = computed(() => {
		return todos.value.filter(todo => todo.completed).length;
	});

	return { todos, completed };
}
```

> :bulb: Совет: обратите внимание, что мы сознательно не включаем функции `addTodo()` и `removeTodo(todo)` здесь. Разделение данных от функций, которые их модифицируют, часто помогает упростить архитектуру приложения. Для более подробной информации, проверьте [data-oriented design](https://en.wikipedia.org/wiki/Data-oriented_design).

Теперь мы можем передать наше состояние приложения списка задач как проп при рендеринге:

```jsx
const state = createAppState();

// ...позже:
<TodoList state={state} />;
```

Это работает в нашем приложении со списком задач, поскольку состояние является глобальным, однако в более крупных приложениях обычно несколько компонентов требуют доступа к одним и тем же частям состояния. Это обычно включает «поднятие состояния вверх» к общему родительскому компоненту. Чтобы избежать ручной передачи состояния через каждый компонент с помощью пропсов, состояние можно поместить в [Context](/guide/v10/context), чтобы любой компонент в дереве мог получить к нему доступ. Вот краткий пример того, как это обычно выглядит:

```jsx
import { createContext } from 'preact';
import { useContext } from 'preact/hooks';
import { createAppState } from './my-app-state';

const AppState = createContext();

render(
	<AppState.Provider value={createAppState()}>
		<App />
	</AppState.Provider>
);

// ...позже когда вам нужен доступ к вашему состоянию приложения
function App() {
	const state = useContext(AppState);
	return <p>{state.completed}</p>;
}
```

Если вы хотите узнать больше о том, как работает контекст, перейдите к документации [Context](/guide/v10/context).

## Локальное состояние с сигналами

Большинство состояния приложения в итоге передается с использованием пропсов и контекста. Однако есть многие сценарии, где компоненты имеют свое собственное внутреннее состояние, специфичное для этого компонента. Поскольку нет причины для этого состояния жить как часть глобальной бизнес-логики приложения, оно должно быть ограничено компонентом, который в нем нуждается. В этих сценариях мы можем создавать сигналы, а также вычисляемые сигналы непосредственно внутри компонентов с использованием хуков `useSignal()` и `useComputed()`:

```jsx
import { useSignal, useComputed } from '@preact/signals';

function Counter() {
	const count = useSignal(0);
	const double = useComputed(() => count.value * 2);

	return (
		<div>
			<p>
				{count} x 2 = {double}
			</p>
			<button onClick={() => count.value++}>нажми меня</button>
		</div>
	);
}
```

Эти два хука — тонкие обёртки вокруг [`signal()`](#signalinitialvalue) и [`computed()`](#computedfn), которые конструируют сигнал первый раз, когда компонент запускается, и просто используют тот же сигнал в последующих рендерах.

> :bulb: За кулисами это реализация:
>
> ```js
> function useSignal(value) {
> 	return useMemo(() => signal(value), []);
> }
> ```

## Продвинутое использование сигналов

Темы, которые мы охватили до сих пор, — всё, что вам нужно, чтобы начать. Следующий раздел предназначен для читателей, которые хотят извлечь ещё больше пользы, моделируя состояние своего приложения полностью с использованием сигналов.

### Реакция на сигналы вне компонентов

При работе с сигналами вне дерева компонентов вы могли заметить, что вычисляемые сигналы не перевычисляются, если вы активно не читаете их значение. Это потому, что сигналы ленивы по умолчанию: они вычисляют новые значения, когда к их значению обратились.

```js
const count = signal(0);
const double = computed(() => count.value * 2);

// Несмотря на обновление сигнала `count`, на котором зависит сигнал `double`,
// `double` еще не обновляется, потому что ничего не использовало его значение.
count.value = 1;

// Чтение значения `double` заставляет его быть перевычисленным:
console.log(double.value); // Логирует: 2
```

Это ставит вопрос: как мы можем подписаться на сигналы вне дерева компонентов? Возможно, мы хотим логировать что-то в консоль каждый раз, когда значение сигнала изменяется, или сохранять состояние в [LocalStorage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage).

Чтобы запускать произвольный код в ответ на изменения сигналов, мы можем использовать [`effect(fn)`](#effectfn). Аналогично вычисляемым сигналам, эффекты отслеживают, какие сигналы запрошены и перезапускают их обратный вызов, когда те сигналы изменяются. В отличие от вычисляемых сигналов, [`effect()`](#effectfn) не возвращает сигнал — это конец последовательности изменений.

```js
import { signal, computed, effect } from '@preact/signals';

const name = signal('Женя');
const surname = signal('Смирных');
const fullName = computed(() => `${name.value} ${surname.value}`);

// Логирует имя каждый раз, когда оно изменяется:
effect(() => console.log(fullName.value));
// Логирует: "Женя Смирных"

// Обновление `name` обновляет `fullName`, что снова вызывает эффект:
name.value = 'Ваня';
// Логирует: "Ваня Смирных"
```

Опционально, вы можете вернуть функцию очистки из колбека, предоставленного [`effect()`](#effectfn), которая будет запущена перед следующим обновлением. Это позволяет вам «очистить» побочный эффект и потенциально сбросить любое состояние для последующего триггера колбека.

```js
effect(() => {
	Chat.connect(username.value);

	return () => Chat.disconnect(username.value);
});
```

Вы можете уничтожить эффект и отписаться от всех сигналов, которые он accessed, вызвав возвращённую функцию.

```js
import { signal, effect } from '@preact/signals';

const name = signal('Женя');
const surname = signal('Смирных');
const fullName = computed(() => name.value + ' ' + surname.value);

const dispose = effect(() => console.log(fullName.value));
// Логирует: "Женя Смирных"

// Уничтожить эффект и подписки:
dispose();

// Обновление `name` не запускает эффект, потому что он был disposed.
// Это также не перевычисляет `fullName` теперь, когда ничего его не наблюдает.
name.value = 'Ваня';
```

> :bulb: Совет: не забывайте очищать эффекты, если вы используете их экстенсивно. Иначе ваше приложение будет потреблять больше памяти, чем нужно.

## Чтение сигналов без подписки на них

В редком случае, когда вам нужно писать в сигнал внутри [`effect(fn)`](#effectfn), но не хотите, чтобы эффект перезапускался, когда этот сигнал изменяется, вы можете использовать `.peek()`, чтобы получить текущую значение сигнала без подписки.

```js
const delta = signal(0);
const count = signal(0);

effect(() => {
	// Обновить `count` без подписки на `count`:
	count.value = count.peek() + delta.value;
});

// Установка `delta` перезапускает эффект:
delta.value = 1;

// Это не перезапустит эффект, потому что оно не accessed `.value`:
count.value = 10;
```

> :bulb: Совет: сценарии, в которых вы не хотите подписываться на сигнал, редки. В большинстве случаев вы хотите, чтобы ваш эффект подписывался на все сигналы. Используйте `.peek()` только когда вам действительно нужно.

В качестве альтернативы `.peek()`, у нас есть функция `untracked`, которая получает функцию как аргумент и возвращает результат функции. В `untracked` вы можете ссылаться на любой сигнал с `.value` без создания подписки. Это может пригодиться, когда у вас есть повторно используемая функция, которая accesses `.value` или вам нужно access более чем 1 сигнал.

```js
const delta = signal(0);
const count = signal(0);

effect(() => {
	// Обновить `count` без подписки на `count` или `delta`:
	count.value = untracked(() => {
		return count.value + delta.value;
	});
});
```

## Объединение нескольких обновлений в одно

Помните функцию `addTodo()`, которую мы использовали раньше в нашем приложении списка задач? Освежим в памяти то, как она выглядела:

```js
const todos = signal([]);
const text = signal('');

function addTodo() {
	todos.value = [...todos.value, { text: text.value }];
	text.value = '';
}
```

Обратите внимание, что функция вызывает два отдельных обновления: одно при установке `todos.value` и другое при установке значения `text`. Это иногда может быть нежелательным и оправдывать объединение обоих обновлений в одно по причинам производительности или другим. Функция [`batch(fn)`](#batchfn) может быть использована, чтобы объединить несколько обновлений значений в один "commit" в конце колбека:

```js
function addTodo() {
	batch(() => {
		todos.value = [...todos.value, { text: text.value }];
		text.value = '';
	});
}
```

Доступ к сигналу, который был изменён внутри пакета, отразит его обновлённое значение. Доступ к вычисляемому сигналу, который был признан недействительным из-за другого сигнала внутри пакета, приведёт к повторному вычислению только необходимых зависимостей, чтобы вернуть актуальное значение для этого вычисляемого сигнала. Все остальные недействительные сигналы остаются незатронутыми и обновляются только в конце обратного вызова пакета.

```js
// --repl
import { signal, computed, effect, batch } from '@preact/signals';

const count = signal(0);
const double = computed(() => count.value * 2);
const triple = computed(() => count.value * 3);

effect(() => console.log(double.value, triple.value));

batch(() => {
	// устанавливаем `count`, делаем недействительными `double` и `triple`:
	count.value = 1;

	// Несмотря на батч, `double` отражает новое вычисленное значение.
	// Однако, `triple` будет обновлен только после завершения колбека.
	console.log(double.value); // Логирует: 2
});
```

> :bulb: Совет: батчи могут также быть вложенными, в этом случае батчированные обновления сбрасываются только после завершения самого внешнего батча колбека.

### Оптимизации рендеринга

С помощью сигналов мы можем обойти рендеринг Virtual DOM и привязать изменения сигналов непосредственно к мутациям DOM. Если передать сигнал в JSX в позицию текста, он будет отображён как текст и автоматически обновляться на месте без сравнения Virtual DOM:

```jsx
const count = signal(0);

function Unoptimized() {
	// Перерендерит компонент при изменении `count`:
	return <p>{count.value}</p>;
}

function Optimized() {
	// Текст автоматически обновляется без перерендеринга компонента:
	return <p>{count}</p>;
}
```

Чтобы включить эту оптимизацию, передайте сигнал в JSX вместо доступа к его свойству `.value`.

Похожая оптимизация рендеринга также поддерживается при передаче сигналов как пропсов на DOM элементах.

## API

Этот раздел — обзор API сигналов. Он предназначен быть быстрым справочником для людей, которые уже знают, как использовать сигналы, и нуждаются в напоминании о том, что доступно.

### signal(initialValue)

Создает новый сигнал с данным аргументом как его начальным значением:

```js
const count = signal(0);
```

Возвращаемый сигнал имеет `.value` свойство, которое можно получить или установить для чтения и записи его значения. Чтобы прочитать из сигнала без подписки на него, используйте `signal.peek()`.

#### useSignal(initialValue)

При создании сигналов внутри компонента используйте вариант хука: `useSignal(initialValue)`. Он функционирует аналогично `signal()` но мемоизирован, чтобы обеспечить, что тот же экземпляр сигнала используется через рендеры компонента.

```jsx
function MyComponent() {
	const count = useSignal(0);
}
```

### computed(fn)

Создает новый сигнал, который вычисляется на основе значений других сигналов. Возвращаемый вычисляемый сигнал доступен только для чтения, и его значение автоматически обновляется, когда любые сигналы, запрашиваемые изнутри функции колбека, изменяются.

```js
const name = signal('Jane');
const surname = signal('Doe');

const fullName = computed(() => `${name.value} ${surname.value}`);
```

#### useComputed(fn)

При создании вычисляемых сигналов внутри компонента используйте вариант хука: `useComputed(fn)`.

```jsx
function MyComponent() {
	const name = useSignal('Jane');
	const surname = useSignal('Doe');

	const fullName = useComputed(() => `${name.value} ${surname.value}`);
}
```

### effect(fn)

Чтобы запускать произвольный код в ответ на изменения сигналов, мы можем использовать `effect(fn)`. Аналогично вычисляемым сигналам, эффекты отслеживают, какие сигналы запрашиваются и перезапускают их колбек, когда те сигналы изменяются. Если колбек возвращает функцию, эта функция будет запущена перед следующим обновлением значения. В отличие от вычисляемых сигналов, `effect()` не возвращает сигнал — это конец последовательности изменений.

```js
const name = signal('Женя');

// Логировать в консоль при изменении `name`:
effect(() => console.log('Привет,', name.value));
// Логирует: "Привет, Женя"

name.value = 'Ваня';
// Логирует: "Привет, Ваня"
```

#### useSignalEffect(fn)

При реагировании на изменения сигналов внутри компонента используйте вариант хука: `useSignalEffect(fn)`.

```jsx
function MyComponent() {
	const name = useSignal('Женя');

	// Логировать в консоль при изменении `name`:
	useSignalEffect(() => console.log('Привет,', name.value));
}
```

### batch(fn)

Функция `batch(fn)` может быть использована, чтобы объединить несколько обновлений значений в один «commit» в конце предоставленного колбека. Батчи могут быть nested и изменения сбрасываются только после завершения самого внешнего батча колбека. Доступ к сигналу, который был модифицирован внутри батча, будет отражать его обновленное значение.

```js
const name = signal('Jane');
const surname = signal('Doe');

// Объединить обе записи в одно обновление
batch(() => {
	name.value = 'John';
	surname.value = 'Smith';
});
```

### untracked(fn)

Функция `untracked(fn)` может быть использована, чтобы запросить значение нескольких сигналов без подписки на них.

```js
const name = signal('Jane');
const surname = signal('Doe');

effect(() => {
	untracked(() => {
		console.log(`${name.value} ${surname.value}`);
	});
});
```

## Утилитарные компоненты и хуки

Начиная с v2.1.0, пакет `@preact/signals/utils` предоставляет дополнительные утилитарные компоненты и хуки, чтобы сделать работу с сигналами еще проще.

### Компонент Show

Компонент `<Show>` предоставляет декларативный способ условно рендерить контент на основе значения сигнала.

```jsx
import { signal } from '@preact/signals';
import { Show } from '@preact/signals/utils';

const isVisible = signal(false);

function App() {
	return (
		<Show when={isVisible} fallback={<p>Здесь не на что смотреть</p>}>
			<p>Теперь вы меня видите!</p>
		</Show>
	);
}

// Вы также можете использовать функцию для access значения
function App() {
	return <Show when={isVisible}>{value => <p>Значение {value}</p>}</Show>;
}
```

### Компонент For

Компонент `<For>` помогает вам рендерить списки из массивов сигналов с автоматическим кешированием отрендеренных элементов.

```jsx
import { signal } from '@preact/signals';
import { For } from '@preact/signals/utils';

const items = signal(['A', 'B', 'C']);

function App() {
	return (
		<For each={items} fallback={<p>Нет элементов</p>}>
			{(item, index) => <div key={index}>Элемент: {item}</div>}
		</For>
	);
}
```

### Дополнительные хуки

#### useLiveSignal(signal)

Хук `useLiveSignal(signal)` позволяет вам создать локальный сигнал, который остается синхронизированным с внешним сигналом.

```jsx
import { signal } from '@preact/signals';
import { useLiveSignal } from '@preact/signals/utils';

const external = signal(0);

function Component() {
	const local = useLiveSignal(external);
	// local будет автоматически обновляться при изменении external
}
```

#### useSignalRef(initialValue)

Хук `useSignalRef(initialValue)` создает сигнал, который ведет себя как реф React со свойством `.current`.

```jsx
import { useSignalEffect } from '@preact/signals';
import { useSignalRef } from '@preact/signals/utils';

function Component() {
	const ref = useSignalRef(null);

	useSignalEffect(() => {
		if (ref.current) {
			console.log('Реф был установлен:', ref.current);
		}
	});

	return (
		<div ref={ref}>
			Ref был прикреплен к элементу {ref.current?.tagName}.
		</div>
	);
}
```
