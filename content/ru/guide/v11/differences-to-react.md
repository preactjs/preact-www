---
title: Отличия от React
description: Какие отличия между Preact и React. Этот документ описывает их подробно
---

# Отличия от React

Preact не предназначен для повторной реализации React. Есть отличия. Многие из этих отличий тривиальны или могут быть полностью устранены с помощью [preact/compat], который является тонким слоем поверх Preact, пытающимся достичь 100% совместимости с React.

Причина, по которой Preact не пытается включить каждый отдельный функционал React, заключается в том, чтобы оставаться **маленьким** и **фокусированным** — иначе имело бы смысл просто отправить оптимизации в проект React, который уже является очень сложным и имеет хорошо спроектированную кодовую базу.

---

<toc></toc>

---

## Основные отличия

Основное отличие между Preact и React заключается в том, что Preact не реализует синтетическую систему событий по причинам размера и производительности. Preact использует стандартный браузерный `addEventListener` для регистрации обработчиков событий, что означает, что именование событий и поведение работает в Preact так же, как в обычном JavaScript / DOM. См. [Справочник событий MDN] для ознакомления с полным списком обработчиков событий DOM.

Стандартные браузерные события работают очень похоже на то, как события работают в React, с несколькими небольшими отличиями. В Preact:

- события не всплывают через компоненты `<Portal>`
- стандартный `onInput` следует использовать вместо `onChange` из React для элементов ввода формы (**только если `preact/compat` не используется**)
- стандартный `onDblClick` следует использовать вместо `onDoubleClick` из React (**только если `preact/compat` не используется**)
- `onSearch` следует использовать для `<input type="search">`, поскольку кнопка очистки «x» не вызывает `onInput` в IE11

Другое заметное отличие заключается в том, что Preact более точно следует спецификации DOM. Пользовательские элементы поддерживаются как любой другой элемент, и пользовательские события поддерживаются с чувствительными к регистру именами (как в DOM).

## Совместимость версий

Для preact и [preact/compat] совместимость версий измеряется по сравнению с _текущими_ и _предыдущими_ основными релизами React. Когда команда React объявляет новые функции, они могут быть добавлены в ядро Preact, если это имеет смысл с учётом [целей проекта]. Это довольно демократичный процесс, постоянно эволюционирующий через обсуждения и решения, принимаемые открыто, с использованием issues и pull requests.

> Таким образом, сайт и документация отражают React `15.x` через `17.x`, с некоторыми дополнениями `18.x` и `19.x`, при обсуждении совместимости или сравнений.

## Сообщения отладки и ошибки

Наша гибкая архитектура позволяет аддонам улучшать опыт Preact любым способом. Один из таких аддонов — `preact/debug`, который добавляет [полезные предупреждения и ошибки](/guide/v10/debugging) и прикрепляет расширение браузера [Preact Developer Tools](https://preactjs.github.io/preact-devtools/), если оно установлено. Они направляют вас при разработке приложений Preact и значительно упрощают проверку того, что происходит. Вы можете включить их, добавив соответствующий оператор импорта:

```js
import 'preact/debug'; // <-- Добавьте эту строку в начало вашего основного файла входа
```

Это отличается от React, который требует наличия бандлера, удаляющего отладочные сообщения во время сборки, проверяя `NODE_ENV != "production"`.

## Функции, уникальные для Preact

Preact фактически добавляет несколько удобных функций, вдохновлённых работой в сообществе (P)React:

### Нативная поддержка модулей ES

Preact был построен с учётом ES-модулей с самого начала и был одним из первых фреймворков, поддерживающих их. Вы можете загружать Preact напрямую в браузерах с помощью ключевого слова `import`, не заставляя его сначала проходить через бандлер.

### Аргументы в `Component.render()`

Для удобства мы передаем `this.props` и `this.state` в метод `render()` в классовых компонентах. Взгляните на этот компонент, который использует один проп и одно состояние.

```jsx
// Работает и в Preact, и в React
class Foo extends Component {
	state = { age: 1 };

	render() {
		return (
			<div>
				Имя: {this.props.name}, возраст: {this.state.age}
			</div>
		);
	}
}
```

В Preact это можно также написать так:

```jsx
// Работает только в Preact
class Foo extends Component {
	state = { age: 1 };

	render({ name }, { age }) {
		return (
			<div>
				Имя: {name}, возраст: {age}
			</div>
		);
	}
}
```

Оба сниппета рендерят точно то же самое, аргументы рендера предоставлены для удобства.

### Необработанные имена атрибутов/свойств HTML

Preact стремится максимально соответствовать спецификации DOM, поддерживаемой всеми основными браузерами. При применении `props` к элементу Preact _определяет_, следует ли устанавливать каждое свойство как свойство или HTML-атрибут. Это позволяет задавать сложные свойства для пользовательских элементов, но также означает, что вы можете использовать имена атрибутов, такие как `class`, в JSX:

```jsx
// Это:
<div class="foo" />

// ...то же самое, что:
<div className="foo" />
```

Большинство разработчиков Preact предпочитают использовать `class` вместо `className`, поскольку это короче писать, но поддерживаются оба варианта.

### SVG внутри JSX

SVG довольно интересно, когда дело доходит до имён его свойств и атрибутов. Некоторые свойства (и их атрибуты) на SVG объектах в camelCase (например, [clipPathUnits на элементе clipPath](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/clipPath#Attributes)), некоторые атрибуты в kebab-case (например, [clip-path на многих SVG элементах](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/Presentation)), и другие атрибуты (обычно унаследованные от DOM, например, `oninput`) — все в нижнем регистре.

Preact применяет атрибуты SVG в том виде, в каком они записаны. Это означает, что вы можете копировать и вставлять немодифицированные фрагменты SVG прямо в ваш код, и они будут работать сразу же. Это обеспечивает большую совместимость с инструментами, которые дизайнеры обычно используют для создания иконок или иллюстраций SVG.

```jsx
// React
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48">
  <circle fill="none" strokeWidth="2" strokeLinejoin="round" cx="24" cy="24" r="20" />
</svg>
// Preact (обратите внимание на stroke-width и stroke-linejoin)
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48">
  <circle fill="none" stroke-width="2" stroke-linejoin="round" cx="24" cy="24" r="20" />
</svg>
```

Если вы пришли из React, вы, возможно, привыкли указывать все атрибуты в формате camelCase. Вы можете продолжать использовать атрибуты SVG в формате camelCase, добавив [preact/compat] в ваш проект, который повторяет API React и нормализует эти атрибуты.

### Используйте `onInput` вместо `onChange`

В основном по историческим причинам семантика события `onChange` в React фактически совпадает с событием `onInput`, предоставляемым браузерами, которое поддерживается повсеместно. Событие `input` лучше всего подходит для большинства случаев, когда вы хотите реагировать на изменение элемента управления формы. В ядре Preact `onChange` — это стандартное [событие изменения DOM](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/change_event), которое срабатывает, когда значение элемента _фиксируется_ пользователем.

```jsx
// React
<input onChange={e => console.log(e.currentTarget.value)} />

// Preact
<input onInput={e => console.log(e.currentTarget.value)} />
```

Если вы используете [preact/compat], большинство событий `onChange` внутренне конвертируются в `onInput` для эмуляции поведения React. Это один из трюков, которые мы используем, чтобы обеспечить максимальную совместимость с экосистемой React.

### Конструктор JSX

JSX — это расширение синтаксиса для JavaScript, которое преобразуется во вложенные вызовы функций. Идея использования этих вложенных вызовов для создания древовидных структур появилась задолго до JSX и ранее была популяризирована в JavaScript проектом [hyperscript]. Этот подход имеет ценность далеко за пределами экосистемы React, поэтому Preact продвигает оригинальный обобщённый стандарт сообщества. Для более глубокого обсуждения JSX и его связи с Hyperscript [прочитайте эту статью о том, как работает JSX](https://jasonformat.com/wtf-is-jsx).

**Исходник:** (JSX)

```jsx
<a href="/">
	<span>Главная</span>
</a>
```

**Вывод:**

```js
// Preact:
h('a', { href: '/' }, h('span', null, 'Главная'));

// React:
React.createElement(
	'a',
	{ href: '/' },
	React.createElement('span', null, 'Главная')
);
```

В конечном итоге, если вы смотрите на сгенерированный выходной код приложения Preact, очевидно, что более короткий «JSX прагма» без пространства имён и легче читается _и_ более подходит для оптимизаций, таких как минификация. В большинстве приложений Preact вы встретите `h()`, хотя название не имеет особого значения, поскольку также предоставляется экспорт псевдонима `createElement`.

### Не требуется contextTypes

Устаревший `Context` API требует, чтобы компоненты объявляли определённые свойства с использованием `contextTypes` или `childContextTypes` в React для получения этих значений. В Preact такого требования нет: все компоненты по умолчанию получают все свойства `context`, созданные методом `getChildContext()`.

## Функции, эксклюзивные для `preact/compat`

`preact/compat` — это наш слой **совместимости**, который переводит код React в Preact. Для существующих пользователей React это может быть простым способом попробовать Preact без изменения вашего кода, путём [настройки нескольких псевдонимов](/guide/v10/getting-started#aliasing-react-to-preact) в конфигурации вашего сборщика.

### Children API

`Children` API — это специализированный набор методов для работы со значением `props.children`. В Preact он обычно не требуется, и мы рекомендуем вместо этого использовать встроенные методы массивов. В Preact `props.children` — это либо узел Virtual DOM, либо пустое значение, такое как `null`, либо массив узлов Virtual DOM. Первые два случая являются самыми простыми и наиболее распространёнными, поскольку можно использовать или возвращать `children` как есть:

```jsx
// React:
function App(props) {
	return <Modal content={Children.only(props.children)} />;
}

// Preact: используйте props.children напрямую:
function App(props) {
	return <Modal content={props.children} />;
}
```

Для специализированных случаев, где вам нужно итерировать по дочерним элементам, переданным компоненту, Preact предоставляет метод `toChildArray()`, который принимает любое значение `props.children` и возвращает плоский и нормализованный массив узлов Virtual DOM.

```jsx
// React
function App(props) {
	const cols = Children.count(props.children);
	return <div data-columns={cols}>{props.children}</div>;
}

// Preact
function App(props) {
	const cols = toChildArray(props.children).length;
	return <div data-columns={cols}>{props.children}</div>;
}
```

React-совместимый `Children` API доступен из `preact/compat` для бесшовной интеграции с существующими библиотеками компонентов.

### Специализированные компоненты

[preact/compat] поставляется со специализированными компонентами, которые не являются обязательными для каждого приложения. Они включают

- [PureComponent](/guide/v10/switching-to-preact#purecomponent): Обновляется только если `props` или `state` изменились
- [memo](/guide/v10/switching-to-preact#memo): Похож по духу на `PureComponent`, но позволяет использовать пользовательскую функцию сравнения
- [forwardRef](/guide/v10/switching-to-preact#forwardref): Поставляет `ref` к указанному дочернему компоненту.
- [Portals](/guide/v10/switching-to-preact#portals): Продолжает рендеринг текущего дерева в другой DOM контейнер
- [Suspense](/guide/v10/switching-to-preact#suspense-experimental): **экспериментально** Позволяет отображать запасной контент в случае, если дерево не готово
- [lazy](/guide/v10/switching-to-preact#suspense-experimental): **экспериментально** Лениво загружает асинхронный код и помечает дерево как готовое/неготовое соответственно.

[целей проекта]: /about/project-goals
[hyperscript]: https://github.com/dominictarr/hyperscript
[preact/compat]: /guide/v10/switching-to-preact
[Справочник событий MDN]: https://developer.mozilla.org/ru/docs/Web/Events
