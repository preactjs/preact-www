---
title: Модульное тестирование с Enzyme
description: Тестирование приложений Preact упрощено с enzyme
---

# Модульное тестирование с Enzyme

[Enzyme](https://airbnb.io/enzyme/) от Airbnb — это библиотека для написания тестов для компонентов React. Он поддерживает разные версии React и React-подобных библиотек с использованием «адаптеров». Есть адаптер для Preact, поддерживаемый командой Preact.

Enzyme поддерживает тесты, которые выполняются в нормальном или headless-браузере с использованием инструмента вроде [Karma](http://karma-runner.github.io/latest/index.html) или тесты, выполняемые в Node с использованием [jsdom](https://github.com/jsdom/jsdom) как фейковой реализации API браузера.

Для подробного введения в использование Enzyme и справочника по API см. [документацию Enzyme](https://airbnb.io/enzyme/). Остальная часть этого руководства объясняет, как настроить Enzyme с Preact, а также способы, которыми Enzyme с Preact отличается от Enzyme с React.

---

<toc></toc>

---

## Установка

Установите Enzyme и адаптер Preact используя:

```bash
npm install --save-dev enzyme enzyme-adapter-preact-pure
```

## Конфигурация

В коде настройки тестов вам нужно настроить Enzyme для использования адаптера Preact:

```js
import { configure } from 'enzyme';
import Adapter from 'enzyme-adapter-preact-pure';

configure({ adapter: new Adapter() });
```

Для руководства по использованию Enzyme с разными раннерами тестов см. раздел [Руководства](https://airbnb.io/enzyme/docs/guides.html) документации Enzyme.

## Пример

Предположим, у нас есть простой компонент `Counter`, который отображает начальное значение с кнопкой для его обновления:

```jsx
import { h } from 'preact';
import { useState } from 'preact/hooks';

export default function Counter({ initialCount }) {
	const [count, setCount] = useState(initialCount);
	const increment = () => setCount(count + 1);

	return (
		<div>
			Текущее значение: {count}
			<button onClick={increment}>Увеличить</button>
		</div>
	);
}
```

Используя раннер тестов вроде mocha или Jest, вы можете написать тест, чтобы проверить, что он работает как ожидается:

```jsx
import { expect } from 'chai';
import { h } from 'preact';
import { mount } from 'enzyme';

import Counter from '../src/Counter';

describe('Counter', () => {
	it('should display initial count', () => {
		const wrapper = mount(<Counter initialCount={5} />);
		expect(wrapper.text()).to.include('Текущее значение: 5');
	});

	it('should increment after "Increment" button is clicked', () => {
		const wrapper = mount(<Counter initialCount={5} />);

		wrapper.find('button').simulate('click');

		expect(wrapper.text()).to.include('Текущее значение: 6');
	});
});
```

Для рабочей версии этого проекта и других примеров см. директорию [examples/](https://github.com/preactjs/enzyme-adapter-preact-pure/blob/master/README.md#example-projects) в репозитории адаптера Preact.

## Как работает Enzyme

Enzyme использует библиотеку адаптера, с которой он был настроен, для рендеринга компонента и его потомков. Адаптер затем конвертирует вывод в стандартизированное внутреннее представление («React Standard Tree»). Enzyme затем оборачивает это объектом, который имеет методы для запроса вывода и триггера обновлений. API объекта `wrapper` использует CSS-подобные [селекторы](https://airbnb.io/enzyme/docs/api/selector.html) для нахождения частей вывода.

## Полный, поверхностный и строковый рендеринг

Enzyme имеет три режима рендеринга:

```jsx
import { mount, shallow, render } from 'enzyme';

// Рендерить полное дерево компонентов:
const wrapper = mount(<MyComponent prop="value" />);

// Рендерить только прямой вывод `MyComponent` (т.е. "мокать" дочерние компоненты
// для рендеринга только как плейсхолдеры):
const wrapper = shallow(<MyComponent prop="value" />);

// Рендерить полное дерево компонентов в HTML строку и парсить результат:
const wrapper = render(<MyComponent prop="value" />);
```

- Функция `mount` рендерит компонент и всех его потомков так же, как они были бы отрендерены в браузере.

- Функция `shallow` рендерит только DOM-узлы, которые напрямую выводятся компонентом. Любые дочерние компоненты заменяются плейсхолдерами, которые выводят только своих детей.

  Преимущество этого режима в том, что вы можете писать тесты для компонентов без зависимости от деталей дочерних компонентов и необходимости конструировать все их зависимости.

  Режим поверхностного рендеринга работает по-другому внутри с адаптером Preact по сравнению с React. См. раздел Различия ниже для деталей.

- Функция `render` (не путать с функцией `render` Preact!) рендерит компонент в HTML строку. Это полезно для тестирования вывода рендеринга на сервере или рендеринга компонента без триггера любых его эффектов.

## Триггер обновлений состояния и эффектов с `act`

В предыдущем примере `.simulate('click')` использовался для клика по кнопке.

Enzyme знает, что вызовы `simulate` вероятно изменят состояние компонента или триггерят эффекты, так что он применит любые обновления состояния или эффекты немедленно перед тем, как `simulate` вернется. Enzyme делает то же самое, когда компонент рендерится первоначально используя `mount` или `shallow` и когда компонент обновляется используя `setProps`.

Если однако событие происходит вне вызова метода Enzyme, такого как прямой вызов обработчика событий (например, проп `onClick` кнопки), тогда Enzyme не будет знать об изменении. В этом случае ваш тест должен триггерить выполнение обновлений состояния и эффектов, а затем попросить Enzyme обновить свое представление вывода.

- Чтобы выполнить обновления состояния и эффекты синхронно, используйте функцию `act` из `preact/test-utils` для оборачивания кода, который триггерит обновления
- Чтобы обновить представление Enzyme о отрендеренном выводе, используйте метод wrapper'а `.update()`

Например, вот другая версия теста для увеличения счетчика, модифицированная для прямого вызова пропа `onClick` кнопки, вместо прохождения через метод `simulate`:

```js
import { act } from 'preact/test-utils';
```

```jsx
it('should increment after "Increment" button is clicked', () => {
	const wrapper = mount(<Counter initialCount={5} />);
	const onClick = wrapper.find('button').props().onClick;

	act(() => {
		// Вызвать обработчик клика кнопки, но на этот раз напрямую, вместо
		// через API Enzyme
		onClick();
	});
	// Обновить представление Enzyme о выводе
	wrapper.update();

	expect(wrapper.text()).to.include('Текущее значение: 6');
});
```

## Различия от Enzyme с React

Общий замысел в том, что тесты, написанные с использованием Enzyme + React, могут быть легко сделаны работоспособными с Enzyme + Preact или наоборот. Это избегает необходимости переписывать все ваши тесты, если вам нужно переключить компонент, первоначально написанный для Preact, чтобы работать с React или наоборот.

Однако есть некоторые различия в поведении между этим адаптером и адаптерами Enzyme для React, о которых нужно знать:

- Режим «поверхностного» рендеринга работает по-другому под капотом. Он согласен с React в рендеринге компонента только «на один уровень в глубину», но, в отличие от React, он создает реальные DOM-узлы. Он также запускает все нормальные жизненные циклы и эффекты.
- Метод `simulate` диспетчерит актуальные DOM-события, в то время как в адаптерах React `simulate` просто вызывает проп `on<EventName>`
- В Preact обновления состояния (например, после вызова `setState`) батчатся вместе и применяются асинхронно. В React обновления состояния могут применяться немедленно или батчиться в зависимости от контекста. Чтобы упростить написание тестов, адаптер Preact сбрасывает обновления состояния и эффекты после начальных рендеров и обновлений, триггерированных через вызовы `setProps` или `simulate` на адаптере. Когда обновления состояния или эффекты триггерируются другими способами, ваш тестовый код может нуждаться в ручном триггере сброса эффектов и обновлений состояния с использованием `act` из пакета `preact/test-utils`.

Для дальнейших деталей см. [README адаптера Preact](https://github.com/preactjs/enzyme-adapter-preact-pure#differences-compared-to-enzyme--react).
