---
title: Обновление с Preact 10.x
description: Обновите ваше приложение Preact 10.x до Preact 11
---

# Обновление с Preact 10.x

Preact 11 стремится быть минимально нарушающим обновлением с Preact 10.x, позволяя нам повысить целевые версии браузеров и очистить некоторый устаревший код. Для большинства пользователей это обновление должно быть простым и быстрым, с только несколькими изменениями, которые могут потребовать внимания.

Этот документ предназначен для того, чтобы помочь вам обновить существующее приложение Preact 10.x до Preact 11. Он охватывает критические изменения и шаги для обеспечения плавного перехода.

---

<toc></toc>

---

## Подготовка ваших приложений

### Поддерживаемые версии браузеров

Preact 11.x будет поддерживать следующие браузеры без каких-либо дополнительных полифилов:

- Chrome >= 40
- Safari >= 9
- Firefox >= 36
- Edge >= 12

Если вам нужно поддерживать более старые версии браузеров, вам потребуется использовать полифилы.

### Поддерживаемые версии TypeScript

TS v5.1 будет новой минимальной поддерживаемой версией для линейки выпусков 11.x. Если вы используете более старую версию, пожалуйста, обновитесь перед обновлением до Preact 11.

Повышение нашей минимальной версии TS позволяет нам воспользоваться некоторыми ключевыми улучшениями, которые команда TS сделала для типизации JSX, исправляя множество давних и фундаментальных проблем с типами, которые мы не могли решить сами.

### ESM-бандлы распространяются как `.mjs`

Preact 11.x будет распространять все ESM-бандлы с расширением `.mjs`, отказываясь от копий `.module.js`, которые предоставлял 10.x. Это должно исправить некоторые проблемы с инструментами, с которыми сталкивались некоторые пользователи, а также упростить бандлы распространения.

Бандлы CJS и UMD будут продолжать предоставляться и остаются неизменными.

## Что нового

### Hydration 2.0

Preact 11 вводит значительные улучшения в процесс гидратации, особенно вокруг приостановки компонентов. В то время как Preact X имел ограничения, требующие от пользователей всегда возвращать ровно 1 DOM-узел на асинхронную границу, Preact 11 позволяет 0 или 2+ DOM-узлов, обеспечивая более гибкий дизайн компонентов.

Следующие примеры теперь действительны в Preact 11:

```jsx
function X() {
  // Некоторая ленивая операция, такая как инициализация аналитики
  return null;
};

const LazyOperation = lazy(() => /* import X */);
```

```jsx
function Y() {
  // `<Fragment>` исчезает при рендеринге, оставляя два `<p>` DOM-элемента
  return (
    <Fragment>
      <p>Foo</p>
      <p>Bar</p>
    </Fragment>
  );
};

const SuspendingMultipleChildren = lazy(() => /* import Y */);
```

Для более полного описания известных проблем и того, как мы их решили, пожалуйста, смотрите [RFC: Hydration 2.0 (preactjs/preact#4442)](https://github.com/preactjs/preact/issues/4442)

### `Object.is` для проверок равенства в аргументах хуков

Preact 11 использует `Object.is` для проверок равенства в аргументах хуков, более точно соответствуя поведению React. В частности, это теперь поддерживает использование `NaN` в качестве значения состояния или зависимости `useEffect`/`useMemo`/`useCallback`.

В Preact 10 следующий пример будет перерендериваться каждый раз при нажатии кнопки, в то время как в Preact 11 нет:

```jsx
import { useState, useEffect } from 'preact/hooks';

function App() {
	const [count, setCount] = useState(0);

	return <button onClick={() => setCount(NaN)}>Установить count в NaN</button>;
}
```

## Изменения API

### Рефы пересылаются по умолчанию

Рефы теперь пересылаются по умолчанию, позволяя использовать их как любой другой проп. Вам больше не нужно использовать `forwardRef` из `preact/compat`, чтобы предоставить эту функциональность.

```jsx
function MyComponent({ ref }) {
	return <h1 ref={ref}>Привет, мир!</h1>;
}

<MyComponent ref={myRef} />;
// Preact 10: myRef.current — экземпляр MyComponent
// Preact 11: myRef.current — DOM-элемент <h1>
```

> **Примечание**: При использовании `preact/compat`, рефы не будут пересылаться к классовым компонентам. React пересылает рефы только к функциональным компонентам, и мы соответствуем этому поведению для тех, кто использует compat-слой.
>
> Для потребителей чистого Preact, **рефы будут пересылаться** к классовым компонентам, так же как к функциональным.

Если вам нужно продолжить использовать старое поведение, вы можете использовать следующий сниппет, чтобы вернуться к поведению Preact 10:

```js
import { options } from 'preact';

const oldVNode = options.vnode;
options.vnode = (vnode) => {
    if (vnode.props.ref) {
        vnode.ref = vnode.props.ref;
        delete vnode.props.ref;
    }

	if (oldVNode) oldVNode(vnode);
}
```

### Перемещение автоматического суффикса `px` для свойств стилей в `preact/compat`

Preact 11 переместил автоматическое добавление суффикса `px` для числовых значений стилей из ядра в `preact/compat`.

```jsx
<h1 style={{ height: 500 }}>Привет, мир!</h1>
// Preact 10: <h1 style="height:500px">Привет, мир!</h1>
// Preact 11: <h1 style="height:500">Привет, мир!</h1>
```

### Перемещение поддержки `defaultProps` в `preact/compat`

Это было перемещено в `preact/compat`, поскольку сегодня используется реже из-за роста функциональных компонентов и хуков.

### Удаление параметра `replaceNode` из `render()`

Третий и опциональный параметр `render()` был удален в Preact 11, поскольку было множество багов и крайних случаев с реализацией, а также некоторые ключевые случаи использования, которые он не мог хорошо поддерживать.

Если это всё ещё вам нужно, мы предоставляем отдельную, совместимую с Preact 10 реализацию через пакет [`preact-root-fragment`](https://github.com/preactjs/preact-root-fragment).

```html
<div id="root">
	<section id="widgetA"><h1>Виджет A</h1></section>
	<section id="widgetB"><h1>Виджет B</h1></section>
	<section id="widgetC"><h1>Виджет C</h1></section>
</div>
```

```jsx
// Preact 10
import { render } from 'preact';

render(<App />, root, widgetC);

// Preact 11
import { render } from 'preact';
import { createRootFragment } from 'preact-root-fragment';

render(<App />, createRootFragment(root, widgetC));
```

### Удаление свойства `Component.base`

Мы убираем `Component.base`, поскольку всегда казалось, что раскрытие DOM, связанного с компонентом, является несовершенным.

Если вам всё ещё нужна эта функциональность, вы можете получить доступ к DOM с `this.__v.__e`; `.__v` — это замаскированное свойство, которое относится к VNode, ассоциированному с компонентом, а `.__e` — DOM-узел, ассоциированный с этим VNode.

### Удаление `SuspenseList` из `preact/compat`

Реализация и поддержка на стороне сервера всегда были немного неясными и неполными, поэтому мы решили удалить этот компонент.

### Типы

#### `useRef` требует начального значения

Аналогично изменению, сделанному в React 19, мы изменили сигнатуру типа `useRef`, чтобы требовать начальное значение. Предоставление начального значения упрощает некоторый вывод типов и помогает пользователям избежать некоторых проблем с типизацией.

#### Сокращение в пространстве имён `JSX`

TypeScript использует специальное пространство имён `JSX`, чтобы изменить, как типизируется и интерпретируется JSX. В v10 мы значительно расширили это пространство имён, включив множество полезных типов, но многие из них лучше реализованы в пространстве имён `preact`.

Начиная с Preact 11, пространство имён `JSX` будет содержать только типы, требуемые TS, такие как `Element`, `IntrinsicElements` и т. д., а остальное будет перемещено в пространство имён `preact`. Это также должно помочь редакторам и IDE при разрешении типов для предложений автоимпорта.

```ts
 // Preact 10
 import { JSX } from 'preact';

 type MyCustomButtonProps = JSX.ButtonHTMLAttributes & { ... }

// Preact 11
 import { ButtonHTMLAttributes } from 'preact';

 type MyCustomButtonProps = ButtonHTMLAttributes & { ... }
```
