---
title: Переход на Preact с React
description: Всё, что вам нужно знать для перехода с React на Preact
---

# Переход на Preact (с React)

`preact/compat` — это наш слой совместимости, который позволяет вам использовать множество библиотек экосистемы React и применять их с Preact. Это рекомендуемый способ попробовать Preact, если у вас есть существующее React-приложение.

Это позволяет вам продолжать писать код React/ReactDOM без каких-либо изменений в вашем рабочем процессе или кодовой базе. `preact/compat` добавляет около 2 КБ к размеру вашего бандла, но имеет преимущество поддержки подавляющего большинства существующих модулей React, которые вы можете найти на npm. Пакет `preact/compat` предоставляет все необходимые настройки поверх ядра Preact, чтобы он работал так же, как `react` и `react-dom`, в одном модуле.

---

<toc></toc>

---

## Настройка compat

Чтобы настроить `preact/compat`, вам нужно настроить алиас `react` и `react-dom` на `preact/compat`. Страница [Первые шаги](/guide/v10/getting-started#aliasing-react-to-preact) подробно описывает, как настроить алиасинг в различных бандлерах.

## PureComponent

Класс `PureComponent` работает аналогично `Component`. Разница в том, что `PureComponent` пропустит рендеринг, когда новые пропсы равны старым. Для этого мы сравниваем старые и новые пропсы через поверхностное сравнение, где мы проверяем каждое свойство пропсов на ссылочное равенство. Это может значительно ускорить приложения, избегая ненужных повторных рендеров. Это работает путём добавления хука жизненного цикла `shouldComponentUpdate` по умолчанию.

```jsx
import { render } from 'preact';
import { PureComponent } from 'preact/compat';

class Foo extends PureComponent {
	render(props) {
		console.log('render');
		return <div />;
	}
}

const dom = document.getElementById('root');
render(<Foo value="3" />, dom);
// Логирует: "render"

// Рендерит второй раз, ничего не логирует
render(<Foo value="3" />, dom);
```

> Обратите внимание, что преимущество `PureComponent` окупается только тогда, когда рендер дорогой. Для простых деревьев дочерних элементов может быть быстрее просто выполнить `render` по сравнению с накладными расходами на сравнение пропсов.

## memo

`memo` эквивалентен функциональным компонентам как `PureComponent` классам. Он использует ту же функцию сравнения под капотом, но позволяет вам указать свою собственную специализированную функцию, оптимизированную для вашего случая использования.

```jsx
import { memo } from 'preact/compat';

function MyComponent(props) {
	return <div>Hello {props.name}</div>;
}

// Использование с функцией сравнения по умолчанию
const Memoed = memo(MyComponent);

// Использование с пользовательской функцией сравнения
const Memoed2 = memo(MyComponent, (prevProps, nextProps) => {
	// Повторно рендерить только когда `name` изменяется
	return prevProps.name === nextProps.name;
});
```

> Функция сравнения отличается от `shouldComponentUpdate` тем, что она проверяет, равны ли два объекта пропсов, тогда как `shouldComponentUpdate` проверяет, отличаются ли они.

## forwardRef

В некоторых случаях при написании компонента вы хотите позволить пользователю получить конкретную ссылку дальше вниз по дереву. С `forwardRef` вы можете как бы «переслать» свойство `ref`:

```jsx
import { createRef, render } from 'preact';
import { forwardRef } from 'preact/compat';

const MyComponent = forwardRef((props, ref) => {
	return <div ref={ref}>Hello world</div>;
});

// Использование: `ref` будет содержать ссылку на внутренний `div` вместо
// `MyComponent`
const ref = createRef();
render(<MyComponent ref={ref} />, dom);
```

Этот компонент наиболее полезен для авторов библиотек.

## Порталы

В редких обстоятельствах вы можете захотеть продолжить рендеринг в другой DOM-узел. Целевой DOM-узел **должен** присутствовать перед попыткой рендеринга в него.

```html
<html>
	<body>
		<!-- App рендерится здесь -->
		<div id="app"></div>
		<!-- Модальные окна должны рендериться здесь -->
		<div id="modals"></div>
	</body>
</html>
```

```jsx
import { createPortal } from 'preact/compat';
import MyModal from './MyModal';

function App() {
	const container = document.getElementById('modals');
	return (
		<div>
			I'm app
			{createPortal(<MyModal />, container)}
		</div>
	);
}
```

> Помните, что из-за того, что Preact повторно использует систему событий браузера, события не будут всплывать через контейнер Portal к другому дереву.

## Suspense

Главная идея за `Suspense` — позволить разделам вашего UI отображать некоторый контент-заполнитель, пока компоненты дальше вниз по дереву всё ещё загружаются. Общий случай использования для этого — разделение кода, где вам нужно загрузить компонент из сети перед тем, как вы сможете его рендерить.

```jsx
import { Suspense, lazy } from 'preact/compat';

const SomeComponent = lazy(() => import('./SomeComponent'));

// Использование
<Suspense fallback={<div>загрузка...</div>}>
	<Foo>
		<SomeComponent />
	</Foo>
</Suspense>;
```

В этом примере UI будет отображать текст `загрузка...` пока `SomeComponent` не загрузится и Promise не разрешится.

> Suspense как в React, так и в Preact пока не полностью завершён или закреплён окончательно. Хотя команда React всё ещё активно отговаривает пользователей напрямую использовать его для получения данных, это шаблон, который некоторые пользователи Preact с радостью применяют в последние несколько лет. Есть несколько известных проблем (пожалуйста, ознакомьтесь с [нашим трекером](https://github.com/preactjs/preact/issues?q=is%3Aissue+is%3Aopen+suspense) для актуальной информации), но в целом он считается достаточно стабильным для использования в продакшене, если вы этого хотите.
>
> Например, этот сайт построен с использованием стратегии получения данных на основе Suspense, которая используется для загрузки всего контента, который вы видите.
