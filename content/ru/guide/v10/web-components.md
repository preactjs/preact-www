---
title: Веб-компоненты
description: Как использовать веб-компоненты с Preact
---

# Веб-компоненты

Веб-компоненты — это набор различных технологий, которые позволяют создавать повторно используемые, инкапсулированные пользовательские HTML-элементы, полностью независимые от фреймворков. Примеры веб-компонентов включают элементы, такие как `<material-card>` или `<tab-bar>`.

Как примитив платформы, Preact [полностью поддерживает веб-компоненты](https://custom-elements-everywhere.com/#preact), обеспечивая бесшовное использование жизненных циклов пользовательских элементов, свойств и событий в ваших приложениях Preact.

Preact и веб-компоненты являются взаимодополняющими технологиями: веб-компоненты предоставляют набор примитивов низкого уровня для расширения браузера, а Preact предоставляет модель компонентов высокого уровня, которая может располагаться поверх этих примитивов.

---

<toc></toc>

---

## Рендеринг веб-компонентов

В Preact веб-компоненты работают так же, как и другие элементы DOM. Их можно визуализировать, используя зарегистрированное имя тега:

```jsx
customElements.define(
  'x-foo',
  class extends HTMLElement {
    // ...
  }
);

function Foo() {
  return <x-foo />;
}
```

### Свойства и атрибуты

JSX не предоставляет возможности различать свойства и атрибуты. Пользовательские элементы обычно полагаются на пользовательские свойства для поддержки установки сложных значений, которые не могут быть выражены как атрибуты. Это хорошо работает в Preact, поскольку средство визуализации автоматически определяет, следует ли устанавливать значения с помощью свойства или атрибута, проверяя затронутый элемент DOM. Когда пользовательский элемент определяет [сеттер](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/set) для данного свойства, Preact обнаруживает его существование и будет использовать сеттер вместо атрибута.

```jsx
customElements.define(
  'context-menu',
  class extends HTMLElement {
    set position({ x, y }) {
      this.style.cssText = `left:${x}px; top:${y}px;`;
    }
  }
);

function Foo() {
  return <context-menu position={{ x: 10, y: 20 }}> ... </context-menu>;
}
```

> **Примечание:** Preact не делает предположений относительно схем именования и не будет пытаться преобразовывать имена, в JSX или иным образом, в свойства DOM. Если пользовательский элемент имеет имя свойства `someProperty`, то его нужно устанавливать с точно таким же регистром и написанием (`someProperty=...`). Использование `someproperty=...` или `some-property=...` не сработает.

При рендеринге статического HTML с использованием `preact-render-to-string` («SSR») сложные значения свойств, такие как объект выше, не сериализуются автоматически. Они применяются после гидратации статического HTML на клиенте.

### Доступ к методам экземпляра

Чтобы получить доступ к экземпляру вашего пользовательского веб-компонента, мы можем использовать ссылки:

```jsx
function Foo() {
  const myRef = useRef(null);

  useEffect(() => {
    if (myRef.current) {
      myRef.current.doSomething();
    }
  }, []);

  return <x-foo ref={myRef} />;
}
```

### Запуск пользовательских событий

Preact нормализует регистр стандартных встроенных событий DOM, которые обычно чувствительны к регистру. Именно по этой причине можно передать свойство onChange в `<input>`, несмотря на то, что фактическое имя события — `"change"`. Пользовательские элементы часто запускают пользовательские события как часть своего общедоступного API, однако невозможно узнать, какие пользовательские события могут быть запущены. Чтобы обеспечить беспрепятственную поддержку пользовательских элементов в Preact, аргументы нераспознанного обработчика событий, передаваемые элементу DOM, регистрируются с использованием их регистра точно так, как указано.

```jsx
// Встроенное событие DOM: прослушивает событие «клика»
<input onClick={() => console.log('клик')} />

// Пользовательский элемент: прослушивает событие TabChange (с учётом регистра!)
<tab-bar onTabChange={() => console.log('смена вкладки')} />

// Исправлено: прослушивается событие «tabchange» (строчные буквы).
<tab-bar ontabchange={() => console.log('смена вкладки')} />
```
